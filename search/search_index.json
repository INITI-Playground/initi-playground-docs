{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"developers/","title":"Developers Guide","text":"<p>Welcome to the Developers Guide! This area is dedicated to game developers who want to create exciting new games for the INITI Playground.</p> <p>With our SDK, you have the tools and resources needed to develop your own custom content and seamlessly integrate it into the INITI Playground. Whether you're looking to build immersive, interactive experiences or innovative educational games, our SDK provides everything you need to bring your creative vision to life.</p> <p>Dive in and start building today, and join our growing community of developers enhancing the INITI Playground experience!</p> <p></p> <p></p> <p>Getting started</p> <p></p>"},{"location":"developers/adding-interactive-objects/","title":"Adding interactive objects","text":"<p>Now that your project is set up and you've tested the touch functionality, it\u2019s time to bring your scene to life by adding interactive objects. To help you get started quickly, the INITI Playground SDK includes several pre-made behaviour and utility scripts that you can easily attach to <code>GameObjects</code> to make them interactive.</p> <p>These scripts are designed to handle common interactions, such as triggering effects, with minimal setup required. By simply adding these scripts to your <code>GameObjects</code>, you can create engaging, interactive experiences without having to write custom code from scratch.</p> <p>Here\u2019s a basic guide on how to use these pre-made scripts. In the following chapter, we\u2019ll explore each available script in detail.</p> <ul> <li>Select a GameObject: In the Unity Editor, choose the <code>GameObject</code> you want to make interactive.</li> <li>Add a Collider: To make the object interactive, it must have a physics collider. The INITI Playground SDK supports both 2D and 3D colliders, so select the collider type that best matches the shape of your object and attach it. If necessary, you can also add multiple colliders to the object.</li> <li>Add a Behavior Script: With the <code>GameObject</code> selected, click the \"Add Component\" button, and choose the script you want to use. The behavior scripts can be found under the path Initi &gt; Behaviour.</li> <li>Configure the Script: After attaching the script, you can customize its properties in the Inspector to fit your needs. Each script has different settings, so we\u2019ll explore the specifics of each one in the next chapter.</li> <li>Test Interactivity: Enter Play mode and interact with the <code>GameObject</code> to see the script in action. If needed, tweak the script settings to achieve the desired behavior.</li> </ul> <p>These pre-made scripts are a great way to quickly prototype and build interactive elements, allowing you to focus on creating unique content for your INITI Playground project. Now that you're familiar with how to use the pre-made scripts, let's take a closer look at each one.</p> <p>Pre-made behaviour scripts</p> <p></p>"},{"location":"developers/behaviour-scripts/","title":"Pre-made behaviour scripts","text":"<p>In this chapter, we will explore the pre-made behavior scripts provided by the INITI Playground SDK. These scripts are designed to streamline the development process by offering ready-to-use functionality for common interactive elements. Each script has specific uses and can help you quickly add interactivity to your game.</p>"},{"location":"developers/behaviour-scripts/#shared-properties","title":"Shared properties","text":"<p>Each behavior script, whether pre-made or custom-built in the future, begins by extending the <code>BaseHittable</code> class. This class provides a <code>Share Collider With Hierarchy</code> property, which is accessible to all behavior scripts.</p> <p></p> <p>Share Collider With Hierarchy property is useful when you have multiple behaviors that you want to trigger from the same hit, but don\u2019t want each object to have its own physics collider. When this property is set to <code>true</code>, the <code>Initi Input Controller</code> checks for any collider, that was hit, within the <code>transform.root</code> and its children. If it finds a collider, it triggers the hit. Conversely, setting <code>Share Collider With Hierarchy</code> to <code>false</code> ensures that the hit is only triggered if the collider is attached to the same <code>GameObject</code> that was hit.</p> <p>Example</p> <p>Example Use Case: Imagine you have a torch, and you want a hit to trigger two actions: spawning a puff of smoke and turning on the fire particles. Instead of creating separate objects and physics colliders for each action, you can create a parent torch object with a single physics collider. Then, add the smoke and fire behaviours as child objects. By setting <code>Share Collider With Hierarchy</code> to <code>true</code>, both actions will use the collider from the parent object, streamlining your setup and reducing complexity.</p>"},{"location":"developers/behaviour-scripts/#spawn-effect","title":"Spawn effect","text":"<p>One of the most straightforward and frequently used behaviors in the INITI Playground SDK is the <code>Spawn Effect</code> behavior. You can locate it by navigating to Initi &gt; Behaviour &gt; SpawnEffect. This behavior triggers a new effect prefab and plays a sound whenever the object is hit. Let's take a closer look at the parameters of this behavior to understand how to customize it for your needs.</p> <p></p> Effect This parameter defines the prefab that will be instantiated when the object is hit. If no prefab is specified, the behavior will only play the assigned sound effect. Effect Sound This is the audio clip that will play when the object is hit. If no audio clip is assigned, the behavior will only instantiate the specified effect prefab. Effect Offset The offset is a <code>Vector3</code> value that determines the position where the effect will be instantiated. If set to <code>Vector3.zero</code>, the effect will be created at the point where the object was hit. Local Rotation This parameter determines the rotation of the instantiated prefab. If set to <code>Vector3.zero</code>, the prefab's <code>localEulerAngles</code> will not be overridden, allowing the prefab to maintain its default rotation. Volume Min Sets the minimum volume level (from a range of <code>0-1</code>) at which the effect's audio will play. When used alongside the <code>Volume Max</code> setting, it allows for randomization of the sound's volume, which is particularly useful for adding variation to repeating sounds. Volume Max Sets the maximum volume level (from a range of <code>0-1</code>) at which the effect's audio will play. When used alongside the <code>Volume Min</code> setting, it allows for randomization of the sound's volume, which is particularly useful for adding variation to repeating sounds. Repeat Delay Specifies the minimum time, in seconds, that must elapse between successive hits before a new effect is spawned. If the object is hit again before this delay period has passed, the hit will be ignored, preventing the effect from being triggered too frequently. Destroy After Spawn When enabled, the object will be destroyed immediately after it is hit. This is useful for creating temporary objects that respond to a hit only once. For instance, you might use this feature for a bubble object that creates a popping effect upon impact and then disappears. Wait For Previous Effect When enabled, the object will delay spawning additional prefabs until the previously instantiated prefab has been destroyed. Destroy Previous Effect When enabled, the object will destroy the previously instantiated prefab upon being hit, and immediately create a new prefab."},{"location":"developers/behaviour-scripts/#toggle-particles","title":"Toggle particles","text":"<p>Another commonly used behavior is the <code>Toggle Particles</code>. You can find it under Initi &gt; Behaviour &gt; ToggleParticles. This behavior is useful for controlling particle effects and lights based on user interactions. It supports two primary use cases: the first is to activate lights and particles upon user touch and automatically turn them off after a set duration. The second mode allows you to toggle the effect on and off with each user interaction.</p> <p></p> Delay The <code>Delay</code> parameter [in seconds] functions differently depending on the <code>Auto End</code> setting. If <code>Auto End</code> is enabled, the delay specifies the time after which the particles and lights will automatically turn off if no further touches occur. If <code>Auto End</code> is disabled, the delay determines the minimum time that must pass between consecutive touches for the hits to be registered, preventing the object from reacting to rapid, repeated touches. Use Particles When enabled, this behavior will manage all particle systems within the object and its child objects. Use Lights When enabled, this behavior will manage all lights within the object and its child objects. Auto Start When enabled, particles and lights will automatically activate as soon as the object is instantiated. Auto End When enabled, particles and lights will automatically turn off if no touch is detected for the duration specified in the <code>Delay</code> parameter. If <code>Auto End</code> is set to false, the object will function as a toggle: the first touch activates the particles and lights, and the next touch deactivates them. To avoid the object being toggled off too quickly, the interval between touches should exceed the time specified in the <code>Delay</code> parameter."},{"location":"developers/behaviour-scripts/#change-color","title":"Change color","text":"<p>The next behavior, <code>ChangeColor</code>, operates similarly to <code>ToggleParticles</code>, but requires a <code>Sprite Renderer</code> component attached to the <code>GameObject</code> to control its color. You can find it under Initi &gt; Behaviour &gt; ChangeColor. This behavior also functions in two modes:</p> <ul> <li>Continuous Mode: The color will remain active as long as there is a continuous touch on the object and will gradually fade away once the touch is removed.</li> <li>Toggle Mode: The color acts like a switch, toggling between an active state and an inactive state with each touch.</li> </ul> <p></p> Start Color This parameter sets the <code>color</code> of the <code>Sprite Renderer</code> when it is in the inactive state. By default, it is set to <code>Color.clear</code> End Color This parameter sets the <code>color</code> of the <code>Sprite Renderer</code> when it is in the active state. The default value is <code>Color.white</code> Fade Time Determines the duration of the transition effect when fading from the active state to the inactive state. Auto Fade When enabled, the object will automatically fade to the inactive state if there is no touch for the duration specified by the <code>Delay</code> parameter. If <code>Auto Fade</code> is disabled, the behavior will act as a toggle switch, manually changing between the active and inactive states with each touch. Delay This parameter specifies the time [in seconds] that must pass before the <code>Auto Fade</code> takes effect. If <code>Auto Fade</code> is enabled, the object will start fading to the inactive state if there is no touch detected for the duration set by this delay. When <code>Auto Fade</code> is disabled, the <code>Delay</code> defines the minimum interval between successive touches; the object will only switch states if touches occur more than this time apart."},{"location":"developers/behaviour-scripts/#spawn-objects","title":"Spawn objects","text":"<p>The final pre-made behavior is the <code>Spawn Objects</code> behavior. While it comes with more settings than the previous behaviors, most of them are straightforward to use. This behavior is useful when you need to create multiple objects either on touch or automatically after a specified time interval. Let's take a closer look at the properties of the <code>Spawn Objects</code> behavior:</p> <p></p> Spawn Settings Objects To Spawn A list of prefabs that the behavior will use to randomly select and spawn an object each time the behavior is triggered. Instead of spawning the same object repeatedly, this property allows for variety by randomly choosing from the list of prefabs you've provided. Spawn Sound An <code>Audio Clip</code> that will play each time the behavior is triggered. If no audio clip is assigned to this property, the spawning action will occur silently. Min Count The minimum number of objects that will be spawned each time the behavior is triggered. Max Count The maximum number of objects that will be spawned each time the behavior is triggered. The exact number of objects spawned will be a random value between the <code>Min Count</code> (inclusive) and <code>Max Count</code> (exclusive) settings Volume Min Sets the minimum volume level (from a range of <code>0-1</code>) at which the <code>Spawn Sound</code> audio will play. When used alongside the <code>Volume Max</code> setting, it allows for randomization of the sound's volume, which is particularly useful for adding variation to repeating sounds. Volume Max Sets the maximum volume level (from a range of <code>0-1</code>) at which the <code>Spawn Sound</code> audio will play. When used alongside the <code>Volume Min</code> setting, it allows for randomization of the sound's volume, which is particularly useful for adding variation to repeating sounds. GameObject Settings Initial Scale Min The minimum size that the spawned objects can be when they first appear in the scene. This value determines the smallest possible scale for the objects. The final scale of each spawned object will be a random value between the <code>Initial Scale Min</code> and <code>Initial Scale Max</code> settings, allowing for variation in the size of the spawned objects. Initial Scale Max The maximum size that the spawned objects can be when they first appear in the scene. This value determines the largest possible scale for the objects. When objects are spawned, their scale will be randomly chosen between the <code>Initial Scale Min</code> and <code>Initial Scale Max</code> settings, providing variation in the size of each spawned object. Spawn Offset Min This offset determines how far and in which direction the spawned object can appear relative to the original object\u2019s position. The final spawn location is determined by randomly selecting a value between the <code>Spawn Offset Min</code> and <code>Spawn Offset Max</code> settings, which allows for variation in where the objects are created Spawn Offset Max When a new object is created, its position is randomly chosen between the Spawn Offset Min and Spawn Offset Max values, allowing you to control the range within which the spawned objects can appear. Physics Settings Initial Speed Min When an object is spawned, an initial force will be applied, with its magnitude randomly chosen between the <code>Initial Speed Min</code> and <code>Initial Speed Max</code> values. This setting only affects objects that have a <code>Rigidbody</code> or <code>Rigidbody2D</code> component; if the object lacks these components, the parameter will be ignored. Initial Speed Max When an object is spawned, an initial force will be applied, with its magnitude randomly chosen between the <code>Initial Speed Min</code> and <code>Initial Speed Max</code> values. This setting only affects objects that have a <code>Rigidbody</code> or <code>Rigidbody2D</code> component; if the object lacks these components, the parameter will be ignored. Initial Torque 2D Min The minimum amount of rotational force (torque) applied to a spawned object's <code>RigidBody2D</code>. This torque is applied randomly between the <code>Initial Torque 2D Min</code> and <code>Initial Torque 2D Max</code> values, which affect how the object will rotate upon spawning. If the object does not have a <code>Rigidbody2D</code> component, this parameter will be ignored. Initial Torque 2D Max The maximum amount of rotational force (torque) applied to a spawned object's <code>RigidBody2D</code>. This torque is applied randomly between the <code>Initial Torque 2D Min</code> and <code>Initial Torque 2D Max</code> values, which affect how the object will rotate upon spawning. If the object does not have a <code>Rigidbody2D</code> component, this parameter will be ignored. Initial Torque 3D Min The minimum amount of rotational force (torque) applied to a spawned object's <code>RigidBody</code>. This torque is randomly chosen between the <code>Initial Torque 3D Min</code> and <code>Initial Torque 3D Max</code> values, influencing how the object will spin upon being spawned. If the object does not have a <code>Rigidbody</code> component, this parameter will be ignored. Initial Torque 3D Max The maximum amount of rotational force (torque) applied to a spawned object's <code>RigidBody</code>. This torque is randomly chosen between the <code>Initial Torque 3D Min</code> and <code>Initial Torque 3D Max</code> values, influencing how the object will spin upon being spawned. If the object does not have a <code>Rigidbody</code> component, this parameter will be ignored. Auto Spawn Auto Spawn When enabled, objects will be instantiated periodically without user interaction. The timing of these automatic spawns is governed by the <code>Auto Spawn Delay Min</code> and <code>Auto Spawn Delay Max</code> parameters. Auto Spawn Delay Min The minimum delay in seconds before the next automatic spawn occurs. Auto Spawn Delay Max The maximum delay in seconds before the next automatic spawn occurs. Simulate Hit On Autospawn When enabled, this behavior automatically triggers a hit event on the <code>transform.root</code> and all its child objects whenever <code>Auto Spawn</code> is triggered. This means that all behaviors attached to the <code>transform.root</code> and its children will receive a simulated touch, as though the user had interacted with the object directly. Repeat settings Repeat Delay The minimum time (in seconds) that must elapse between successive user hits. This setting helps manage how frequently an object can be interacted with by the user. Destroy After Spawn When enabled, the object will be destroyed immediately after it is hit. This is useful for creating temporary objects that respond to a hit only once. Wait For Previous Objects When enabled, this setting ensures that new hits are ignored until all child objects of the behavior's <code>GameObject</code> are no longer present. This is useful if you want to maintain a single instance of a spawned object at a time and delay the spawning of new objects until the previous instance has been destroyed. Destroy Previous Objects When enabled, this setting ensures that any existing child objects of this behavior are destroyed before new objects are spawned. This is useful when you want to ensure that only a single instance of a spawned object exists at any given time. Spawn As Children When enabled, this setting ensures that newly spawned objects become child objects of the <code>GameObject</code> to which this behavior is attached. This is important because both the <code>Wait For Previous Objects</code> and <code>Destroy Previous Objects</code> settings operate specifically on child objects of the behavior's <code>GameObject</code>. By enabling <code>Spawn as Children</code>, you ensure that these parameters function as intended, allowing for proper management of the spawned objects, including waiting for previous objects to be destroyed or handling their destruction before new ones are spawned. <p>This concludes our chapter on the pre-made behavior scripts included with the INITI Playground SDK. These scripts are designed to help you get started quickly with interactive elements in your project. In the next chapter, we will explore the pre-made utility scripts available in the SDK.</p> <p>Pre-made utilily scripts</p> <p></p>"},{"location":"developers/extending-behaviors/","title":"Extending functionality","text":""},{"location":"developers/extending-behaviors/#adding-custom-interactive-objects","title":"Adding custom interactive objects","text":"<p>To create custom interactive objects with unique behaviors, you\u2019ll need to extend the <code>BaseHittable</code> class, the base class of all interactive objects in INITI Playground. By extending <code>BaseHittable</code>, you can implement your own logic that responds to hits or touches, giving you complete control over how your objects react to user interactions.</p> <p>This flexibility allows you to create everything from simple reactions to complex sequences of events, tailored specifically to your game's needs. If you want to add custom animations, trigger specific audio effects, or implement gameplay mechanics, you will need to extend <code>BaseHittable</code> class and override the <code>Hit(Vector3 hitPosition)</code> method.</p>"},{"location":"developers/extending-behaviors/#example","title":"Example","text":"<p>In the following example, we'll explore how to create a custom behavior that takes a list of colors as a parameter and changes the <code>SpriteRenderer</code>'s color to the next one in the list each time the object is hit.</p> <ol> <li>First, right-click in the Project window, and select Create &gt; C# Script to create a new script. Name the script RotateColorsBehaviour</li> <li>Now we need to extend the <code>BaseHittable</code> class, which is the base class for all interactive objects and override the <code>Hit(Vector3 hitPosition)</code> method. <pre><code>using initi.behaviour;\nusing UnityEngine;\n\npublic class RotateColorsBehaviour : BaseHittable\n{\n    // Start is called before the first frame update\n    void Start()\n    {\n\n    }\n\n    public override void Hit(Vector3 hitPosition)\n    {\n        base.Hit(hitPosition);\n    }\n}\n</code></pre></li> <li>Now, we can start implementing our custom logic. Let's begin by adding some properties our script will use. <pre><code>public class RotateColorsBehaviour : BaseHittable\n{\n    public List&lt;Color&gt; colors;\n    public float delay = 0.5f;\n    private int currentColor = 0;\n    private float lastTouchTime = 0f;\n    private SpriteRenderer spriteRenderer;\n\n    ...\n}\n</code></pre><ul> <li>colors - A <code>List</code> that will store the colors that the <code>SpriteRenderer</code> will cycle through each time the object is hit.</li> <li>delay - Sets the minimum time between hits. The script will check if enough time has passed since the last hit before processing the next one. If the object is hit too quickly (before the delay time has elapsed), the hit will be ignored.</li> <li>currentColor - The index of the currently selected color.</li> <li>lastTouchTime - The last time object was hit.</li> <li>spriteRenderer - Reference to <code>SpriteRenderer</code> component.</li> </ul> </li> <li>Next, we\u2019ll assign the reference to the <code>SpriteRenderer</code> component to our property. Since this script relies on the <code>SpriteRenderer</code> being attached to the object, it\u2019s a good practice to include the <code>RequireComponent</code> attribute. This way, Unity will automatically add a <code>SpriteRenderer</code> to the object when you attach this script. <pre><code>[RequireComponent(typeof(SpriteRenderer))]\npublic class RotateColorsBehaviour : BaseHittable\n{\n    ...\n\n    // Start is called before the first frame update\n    void Start()\n    {\n        spriteRenderer = GetComponent&lt;SpriteRenderer&gt;();\n    }\n\n    ...\n}\n</code></pre></li> <li>If the color list isn't empty, we'll initialize the <code>SpriteRenderer</code>'s color to the first color in the list when the script starts. <pre><code>[RequireComponent(typeof(SpriteRenderer))]\npublic class RotateColorsBehaviour : BaseHittable\n{\n    ...\n\n    // Start is called before the first frame update\n    void Start()\n    {\n        spriteRenderer = GetComponent&lt;SpriteRenderer&gt;();\n        if(colors.Count &gt; 0) spriteRenderer.color = colors[currentColor];\n    }\n\n    ...\n}\n</code></pre></li> <li>Now that everything is set up, we can implement our custom logic in the <code>Hit</code> method we overrode earlier. <pre><code>[RequireComponent(typeof(SpriteRenderer))]\npublic class RotateColorsBehaviour : BaseHittable\n{\n    ...\n\n    public override void Hit(Vector3 hitPosition)\n    {\n        base.Hit(hitPosition);\n        if (Time.time &gt; (lastTouchTime + delay))\n        {\n            currentColor++;\n            if(currentColor &gt;= colors.Count) currentColor = 0;\n            spriteRenderer.color = colors[currentColor];\n            lastTouchTime = Time.time;\n        }\n    }\n}\n</code></pre><ul> <li>The condition <code>if (Time.time &gt; (lastTouchTime + delay))</code> checks if enough time has passed since the last hit. Time.time gives the current time in seconds since the start of the game. If the current time is greater than the time of the last touch plus the specified delay, the hit will be processed. This ensures that hits occurring too close together (within the delay period) are ignored.</li> <li>Next, we increment the <code>currentColor</code> index, which keeps track of the current color in the colors list. If the index reaches the end of the list (i.e., it's greater than or equal to the number of colors), it resets to 0, cycling back to the first color.</li> <li>The <code>spriteRenderer</code>'s color is updated to the new color selected from the colors list based on the <code>currentColor</code> index.</li> <li>Lastly, the <code>lastTouchTime</code> variable is updated to the current time, marking when the last valid hit occurred. This ensures that the delay logic works correctly for subsequent hits.</li> </ul> </li> <li>Here is the complete code: <pre><code>using initi.behaviour;\nusing System.Collections.Generic;\nusing UnityEngine;\n\n[RequireComponent(typeof(SpriteRenderer))]\npublic class RotateColorsBehaviour : BaseHittable\n{\n    public List&lt;Color&gt; colors;\n    public float delay = 0.5f;\n    private int currentColor = 0;\n    private float lastTouchTime = 0f;\n    private SpriteRenderer spriteRenderer;\n\n    // Start is called before the first frame update\n    void Start()\n    {\n        spriteRenderer = GetComponent&lt;SpriteRenderer&gt;();\n        if(colors.Count &gt; 0) spriteRenderer.color = colors[currentColor];\n    }\n\n    public override void Hit(Vector3 hitPosition)\n    {\n        base.Hit(hitPosition);\n        if (Time.time &gt; (lastTouchTime + delay))\n        {\n            currentColor++;\n            if(currentColor &gt;= colors.Count) currentColor = 0;\n            spriteRenderer.color = colors[currentColor];\n            lastTouchTime = Time.time;\n        }\n    }\n}\n</code></pre></li> <li>Your new behavior is now ready for use in the game. Attach the script to your <code>GameObject</code>, populate the color list, and observe how the color changes with each hit. Be sure to also add a <code>Collider</code> or <code>Collider2D</code> component to the object, so it can respond to hits.    </li> </ol> <p></p> <p>That's it! As you can see, adding interactive objects with custom logic is straightforward. This example is very simple, but with this foundation, you're well-equipped to create interactive objects with more complex behaviors. Experiment with different ideas and expand upon this to fit the needs of your project.</p>"},{"location":"developers/extending-behaviors/#extending-initi-input-controller","title":"Extending <code>Initi Input Controller</code>","text":"<p>The <code>Initi Input Controller</code> manages inputs from various sources, such as mouse clicks or touch events, and relays hit events to interactive objects. If a hit is detected but no interactive object is present at the hit location, the <code>MissRegistered</code> method is triggered. For detailed information about configuring the <code>Initi Input Controller</code>, please refer to the Setting up a new project section of this documentation. In this section, we will explore how to implement custom logic for handling hits or misses.</p>"},{"location":"developers/extending-behaviors/#custom-hit-logic","title":"Custom hit logic","text":"<p>In this example, we will extend the <code>Initi Input Controller</code> and override the <code>HitRegistered</code> method to track the number of hits. This approach can serve as a simple implementation of a scoring system or any other functionality that depends on counting hits.</p> <ol> <li>Right-click in the Project window, and select Create &gt; C# Script to create a new script. Name the script CustomInputController.</li> <li>Extend the <code>InitiInputController</code> class and override the <code>HitRegistered(GameObject hitObject, Vector3 hitPosition)</code> method method to implement our custom hit logic. <pre><code>using initi.input;\nusing UnityEngine;\n\npublic class CustomInputController : InitiInputController\n{\n    public override void HitRegistered(GameObject hitObject, Vector3 hitPosition)\n    {\n        base.HitRegistered(hitObject, hitPosition);\n    }\n}\n</code></pre> <p>It's important to include a call to <code>base.HitRegistered(hitObject, hitPosition);</code> within the method to ensure that the base input functionality is preserved.</p> </li> <li>Now, we can proceed with implementing the hit counter logic. <pre><code>public class CustomInputController : InitiInputController\n{\n    private int touchCount = 0;\n\n    public override void HitRegistered(GameObject hitObject, Vector3 hitPosition)\n    {\n        base.HitRegistered(hitObject, hitPosition);\n        touchCount++;\n        Debug.Log(\"Touches registered: \" + touchCount);\n    }\n\n    public int GetTouchCount()\n    {\n        return touchCount;\n    }\n}\n</code></pre></li> <li>That's it! Our <code>CustomInputController</code> now tracks the number of successful hits and includes a getter method to access this count, which can be useful for example for displaying score in a UI. The final step is to replace the default <code>InitiInputController</code> with our custom version to ensure our new logic is in use.  </li> <li>When you run the scene and interact with any behavior, you should see the hit count increase, which will be displayed in the console.</li> </ol>"},{"location":"developers/extending-behaviors/#custom-miss-logic","title":"Custom miss logic","text":"<p>Creating custom logic for misses follows the same approach as for hits. The only difference is that you need to override the <code>MissRegistered(Ray ray)</code> method instead of <code>HitRegistered(GameObject hitObject, Vector3 hitPosition)</code>. The code below demonstrates how to implement a miss counter, similar to the hit counter example.</p> <pre><code>using initi.input;\nusing UnityEngine;\n\npublic class CustomInputController : InitiInputController\n{\n    private int missCount = 0;\n\n    public override void MissRegistered(Ray ray)\n    {\n        base.MissRegistered(ray);\n        missCount++;\n        Debug.Log(\"Misses registered: \" + missCount);\n    }\n\n    public int GetMissCount()\n    {\n        return missCount;\n    }\n}\n</code></pre> <p>Creating custom miss logic can be useful if you want to replace the default effects or sounds with more dynamic responses. For instance, you can implement multiple effects or sounds that are randomly selected when a miss occurs, adding variety and enhancing the user experience.</p> <p>With this knowledge, you're ready to begin developing your games for INITI Playground. If you have any questions or need assistance, please don't hesitate to reach out via the contact form in the Help section. In the next part of this documentation, we'll cover how to install and uninstall your custom games to INITI Playground so you can start playing them.</p> <p></p> <p>Preparing games for installation</p> <p></p>"},{"location":"developers/getting-started/","title":"Getting started","text":"<p>The first step in creating games for the INITI Playground is to choose the SDK for the game engine you want to use. Currently, we offer an SDK for the Unity engine, allowing you to build custom content.</p> <p>Future updates will include SDKs for other popular game engines, expanding your options and flexibility for development. Stay tuned for these additions, and in the meantime, get started with our INITI Playground SDK for Unity to bring your innovative game ideas to life on the INITI Playground.</p>"},{"location":"developers/getting-started/#get-initi-playground-sdk","title":"Get INITI Playground SDK","text":"<p>SDK for Unity</p> <p></p>"},{"location":"developers/installing-games/","title":"Installing games on INITI Playground","text":"<p>This guide will walk you through the process of installing a game on INITI Playground using a USB drive.</p>"},{"location":"developers/installing-games/#video-guide","title":"Video guide","text":"<ul> <li> <p>For a quick start, check out our video guide:</p> <p> </p> </li> </ul>"},{"location":"developers/installing-games/#prerequisites","title":"Prerequisites","text":"<p>Before installing the game, ensure you have completed the following steps:</p> <ul> <li>Prepared the game ZIP file by following the this guide.</li> <li>Copied the ZIP file to a USB drive.</li> <li>Updated INITI Playground to version 1.0.7 or higher.</li> </ul>"},{"location":"developers/installing-games/#installing-games","title":"Installing games","text":"<ul> <li> <p>Open the UI and click on the <code>Settings</code> tab at the top of the screen. Locate the games setup section, as illustrated in the picture below.</p> <p> </p> </li> <li> <p>Connect your USB drive to the INITI Playground computer.</p> </li> <li>Wait a few seconds for the system to recognize the USB drive.</li> <li> <p>The system will automatically detect the drive and begin loading the list of available games.</p> <p> </p> </li> <li> <p>Once the list is loaded, you will see the games available for installation in the <code>Available Games</code> panel on the left.</p> <p> </p> </li> <li> <p>Locate your game in the list. </p> <p>Note</p> <p>If your game does not appear, check the Preparing Games for INITI Playground Guide.</p> </li> <li> <p>Select your game and click the <code>Install</code> button.</p> <p> </p> </li> <li> <p>Confirm installation and wait for the installation process to complete</p> <p> </p> </li> <li> <p>Once the installation is complete, the game will appear in the <code>Installed games</code> panel on the right and the game in <code>Available games</code> panel is marked as <code>INSTALLED</code>.</p> <p> </p> </li> </ul>"},{"location":"developers/installing-games/#updating-games","title":"Updating games","text":"<ul> <li> <p>Updating a game works similarly to installing a new one, but with the added convenience of replacing the previous version. If a newer version of the game is found on the USB drive compared to the one currently installed, an <code>Update</code> button will appear, allowing you to quickly install the latest version while removing the old one, as shown in the following picture.</p> <p> </p> <p> <code>Please note that the available game version is 1.0.1, while the currently installed version is 1.0.0.</code> </p> </li> <li> <p>To update, simply click the <code>Update</code> button and confirm. The previous version will be automatically uninstalled, and the new version will be installed in its place.</p> <p> </p> </li> </ul> <p>In the following section, we will cover how to remove games from INITI Playground.</p> <p></p> <p>Uninstalling games from INITI Playground</p> <p></p>"},{"location":"developers/preparing-games/","title":"Preparing games for installation","text":"<p>Before uploading a game to INITI Playground, you need to create a few essential files. This includes the <code>metadata.json</code> file, which contains key details such as the game ID, name, and version, as well as <code>PNG images</code> for the game's menu graphics. These files, along with the game data, must be packaged into a ZIP file. This section will guide you through the process step by step.</p>"},{"location":"developers/preparing-games/#prerequisites","title":"Prerequisites","text":"<ul> <li>Game created using our SDK</li> <li>Empty USB drive</li> <li>INITI Playground updated to version 1.0.7 or later</li> </ul>"},{"location":"developers/preparing-games/#creating-a-metadatajson-file","title":"Creating a <code>metadata.json</code> file","text":"<p>The <code>metadata.json</code> file contains key information about the game, such as its name, version, and supported screen ratios. This guide will walk you through creating and structuring this file properly. </p>"},{"location":"developers/preparing-games/#understanding-the-metadatajson-structure","title":"Understanding the <code>metadata.json</code> structure","text":"<pre><code>{\n    \"id\":\"com.initiplayground.point\",\n    \"name\":\"Point\",\n    \"description\":\"Simple training game\",\n    \"executablePath\":\"Point.exe\",\n    \"version\":\"1.0.1\",\n    \"supportedRatios\":[\"16x9\", \"16x10\", \"4x3\", \"5x4\"],\n    \"tags\":[\"Default\", \"Fitness\", \"Competitive\", \"Teams\", \"Sport\"]\n}\n</code></pre> id (String, Required) A unique identifier for the game, following the reverse domain notation (e.g., <code>\"com.companyName.gameName\"</code>). name (String, Required) The display name of the game as it will appear in INITI Playground. description (String, Optional) A brief description of the game\u2019s purpose or gameplay. executablePath (String, Required) The name of the main executable file that starts the game (e.g., <code>\"MyGame.exe\"</code>). version (String, Required) The current version of the game in <code>major.minor.patch</code> format (e.g., <code>\"1.0.1\"</code>). supportedRatios (Array, Required) A list of aspect ratios the game supports (e.g., <code>[\"16x9\", \"4x3\"]</code>). These ensure the game displays correctly on different screen sizes. tags (Array, Optional) A set of keywords that help categorize the game."},{"location":"developers/preparing-games/#how-to-create-the-metadatajson-file","title":"How to create the <code>metadata.json</code> file","text":"<ul> <li>Open a text editor such as Notepad++, VS Code, or any JSON editor.</li> <li>Copy and paste the example JSON structure above.</li> <li>Replace the values with your game\u2019s details.</li> <li>Save the file as <code>metadata.json</code> in UTF-8 encoding to ensure compatibility.</li> <li>Place it in the root directory of your game, alongside the executable.</li> </ul>"},{"location":"developers/preparing-games/#validating-the-json-file","title":"Validating the JSON file","text":"<p>Before proceeding, validate your <code>metadata.json</code> to ensure it\u2019s formatted correctly. You can use an online JSON validator such as jsonlint.com</p>"},{"location":"developers/preparing-games/#creating-menu-graphics","title":"Creating menu graphics","text":"<p>To properly display your game in INITI Playground, you need to provide two PNG images for the game menu:</p> <ul> <li>Window Image \u2013 A background image representing your game.</li> <li>Button Image \u2013 A logo or stylized game title for selection.</li> </ul> <p>This guide will walk you through the specifications and best practices for creating these images.</p>"},{"location":"developers/preparing-games/#window-image-game-preview-banner","title":"Window Image (Game Preview Banner)","text":"<p>The window image serves as the background for the game menu, giving players a preview of the game\u2019s theme.</p> <p></p> Format PNG Resolution 1872x1024 File Name This file must be named <code>windowImage.png</code>"},{"location":"developers/preparing-games/#button-image-game-selection-icon","title":"Button Image (Game Selection Icon)","text":"<p>This smaller image is used as a selection button for the game in the INITI Playground menu. It should be simple, clear, and easy to recognize.</p> <p></p> Format PNG Resolution 640x390 File Name This file must be named <code>buttonImage.png</code>"},{"location":"developers/preparing-games/#best-practices-for-menu-graphics","title":"Best practices for menu graphics","text":"<ul> <li>Keep It Clean &amp; Readable<ul> <li>Avoid excessive detail or small elements.</li> <li>Use clear, high-contrast text.</li> </ul> </li> <li>Maintain Consistency<ul> <li>Keep a unified color scheme and style across both images.</li> </ul> </li> </ul>"},{"location":"developers/preparing-games/#placing-the-images-in-your-game-folder","title":"Placing the images in your game folder","text":"<p>Both <code>windowImage.png</code> and <code>buttonImage.png</code> must be placed in the root folder of your game, along with <code>metadata.json</code> and the executable file.</p> <pre><code>/MyGame/\n\u251c\u2500\u2500 buttonImage.png\n\u251c\u2500\u2500 metadata.json\n\u251c\u2500\u2500 MyGame.exe\n\u251c\u2500\u2500 MyGame_Data/\n\u251c\u2500\u2500 windowImage.png\n</code></pre> <p>Once you\u2019ve created these images and placed them in the correct location, you\u2019re ready to package your game into a ZIP file for installation.</p>"},{"location":"developers/preparing-games/#creating-a-zip-file-for-initi-playground","title":"Creating a ZIP file for INITI Playground","text":"<p>To upload a game to INITI Playground, you must package all required files into a ZIP archive. It is crucial that the ZIP file does not contain any additional folders - the files must be in the root of the archive.</p>"},{"location":"developers/preparing-games/#check-the-file-structure","title":"Check the file structure","text":"<p>Before creating the ZIP file, ensure your game folder contains the following files in its root directory:</p> <ul> <li><code>metadata.json</code> \u2013 Contains game information.</li> <li><code>MyGame.exe</code> \u2013 The main game executable.</li> <li><code>windowImage.png</code> \u2013 The game menu background.</li> <li><code>buttonImage.png</code> \u2013 The game selection button.</li> <li>Any other necessary game files (e.g., assets, DLLs).</li> </ul> <p>Correct file structure before zipping:</p> <pre><code>/MyGame/\n\u251c\u2500\u2500 buttonImage.png\n\u251c\u2500\u2500 metadata.json\n\u251c\u2500\u2500 MyGame.exe\n\u251c\u2500\u2500 MyGame_Data/\n\u251c\u2500\u2500 windowImage.png\n\u251c\u2500\u2500 Other_Game_Files..\n</code></pre> <p>Warning</p> <p>Do NOT place the files inside an extra folder within the ZIP</p> <pre><code>\u274c Wrong Structure (Creates an extra folder)\n/MyGame.zip\n    \u251c\u2500\u2500 MyGame/\n            \u251c\u2500\u2500 metadata.json\n            \u251c\u2500\u2500 MyGame.exe\n            \u251c\u2500\u2500 windowImage.png\n</code></pre>"},{"location":"developers/preparing-games/#create-zip-using-windows-file-explorer","title":"Create zip using Windows File Explorer","text":"<ol> <li>Select all required files inside your game folder (DO NOT select the folder itself).</li> <li>Right-click on the selected files and choose <code>Send to \u2192 Compressed (zipped) folder</code>.</li> <li>Rename the ZIP file to match your game\u2019s name (e.g., <code>MyGame.zip</code>).</li> </ol>"},{"location":"developers/preparing-games/#create-zip-using-windows-powershell","title":"Create zip using Windows PowerShell","text":"<ol> <li>Open Command Prompt (<code>Win + R</code>, type <code>powershell</code>, and press <code>Enter</code>).</li> <li> <p>Navigate to your game folder using the <code>cd</code> command:</p> <pre><code>cd C:\\Path\\To\\MyGame\n</code></pre> </li> <li> <p>Run the following command to create a ZIP file:</p> <pre><code>Compress-Archive -Path * -DestinationPath MyGame.zip\n</code></pre> <p>This ensures all files are added without creating a subfolder.</p> </li> </ol> <p>Once you have successfully created your ZIP file, the final step is to copy it to a USB drive for installation on INITI Playground.</p>"},{"location":"developers/preparing-games/#copy-the-zip-zile-to-usb-drive","title":"Copy the ZIP zile to USB drive","text":"<ol> <li>Insert your USB drive into your computer.</li> <li>Open the folder where your ZIP file is located.</li> <li>Right-click the ZIP file (e.g., <code>MyGame.zip</code>) and select Copy.</li> <li>Open <code>File Explorer</code> and navigate to your USB drive.</li> <li>Paste the ZIP file onto the USB drive (<code>Right-click \u2192 Paste</code>).</li> <li>Safely eject the USB drive before removing it.</li> </ol> <p>With the game ZIP file on your USB drive, you can now proceed to install it to INITI Playground.</p> <p></p> <p>Installing games to INITI Playground</p> <p></p>"},{"location":"developers/testing-touch-using-simulator/","title":"Testing touch using simulator","text":"<p>While testing input using the mouse directly from the editor is convenient, it's also good practice to periodically test native input with a simulator. A simulator is an external application that emulates native touches, allowing you to test how INITI Playground responds as if the touches were coming from the sensor. Since INITI Playground uses the TUIO protocol for communication with the touch sensor, any TUIO-compatible simulator should work. For this documentation, we will use Greg Harding's Unity/C# implementation as our example.</p>"},{"location":"developers/testing-touch-using-simulator/#download-tuio-simulator","title":"Download TUIO simulator","text":"<ul> <li>Visit the GitHub repository for the TUIO simulator by Greg Harding.</li> <li>Navigate to the Releases section.</li> <li>Download and unzip the latest release for your OS (<code>TUIOSimulator_v1.2_win_x86_64.zip</code> if you are using Windows)</li> </ul>"},{"location":"developers/testing-touch-using-simulator/#simulator-settings","title":"Simulator settings","text":"<ul> <li>Run the application (<code>TUIOSimulator.exe</code> on Windows)</li> <li>The only setting that needs adjustment from the default is the server port. Since INITI Playground's games are configured to listen on port <code>33333</code>, make sure to set the server port to this number.</li> </ul>"},{"location":"developers/testing-touch-using-simulator/#using-simulator","title":"Using simulator","text":"<ul> <li>Once you\u2019ve set the server port correctly, click the big Play button in the center of the simulator window.</li> <li>In Unity, enter Play mode by clicking the Play button.</li> <li> <p>In TUIO Simulator, click anywhere in the gray area in the center. You should see the touch registered in Unity, with the miss effect spawning as a result.</p> <p>Note</p> <p>If Unity doesn't register the touches from the simulator, double-check that the port number is set correctly and that Run In Background is enabled in the Project Settings.</p> </li> </ul> <p></p> <p></p> <p>Adding interactive objects</p> <p></p>"},{"location":"developers/uninstalling-games/","title":"Uninstalling games from INITI Playground","text":"<p>If you wish to remove any games from INITI Playground, this guide will walk you through the process.</p> <ul> <li> <p>Open the UI and click on the <code>Settings</code> tab at the top of the screen. Locate the games setup section, as illustrated in the picture below.</p> <p> </p> </li> <li> <p>Find the game you wish to remove in the <code>Installed games</code> panel on the right side, then click <code>Delete</code> button.</p> </li> <li> <p>Confirm and wait for the game to be removed</p> <p> </p> <p> </p> </li> <li> <p>Once the game is uninstalled, it will no longer appear in the <code>Installed games</code> list.</p> </li> </ul>"},{"location":"developers/unity-sdk-download/","title":"Download INITI Playground SDK for Unity","text":"<p>The INITI Playground SDK is available as a package for the Unity engine on our GitHub page. To get started, you will need to add it to your project using the Unity Package Manager.</p>"},{"location":"developers/unity-sdk-download/#adding-package-from-git-url","title":"Adding package from git URL","text":"<p>Prerequisites</p> <p>To use Git packages in a project, Git must be installed on the user machine. The Git executable path should be listed in the PATH system environment variable.</p> <ul> <li>Open Package Manager (<code>Window &gt; Package Manager</code>)</li> <li>Click the plus icon located at the top left corner and elect <code>Add package from git URL...</code></li> </ul> <p></p> <ul> <li>Paste the git URL and click <code>Add</code></li> </ul> <pre><code>https://github.com/INITI-Playground/INITIPlaygroundSDK-UnityPackage.git\n</code></pre> <ul> <li>Unity will download the package and add it into your project</li> </ul> <p></p>"},{"location":"developers/unity-sdk-download/#adding-package-from-disk","title":"Adding package from disk","text":"<ul> <li>Visit our GitHub repository</li> <li>Navigate to the Releases section.</li> <li>Download and unzip the latest release</li> </ul> <ul> <li>Open Package Manager (<code>Window &gt; Package Manager</code>)</li> <li>Click the plus icon located at the top left corner and elect <code>Add package from disk...</code></li> <li>Locate the <code>package.json</code> file and click <code>Open</code></li> </ul> <ul> <li>Unity will add the package into your project</li> </ul> <p>Now that you have added the INITI Playground package to your project, let's begin the setup</p> <p>Setting up a new project</p> <p></p>"},{"location":"developers/unity-setting-up-project/","title":"Setting up a new project","text":"<p>Prerequisites</p> <p>Ensure you have completed the SDK installation guide and added the INITI Playground package to your project.</p>"},{"location":"developers/unity-setting-up-project/#project-settings","title":"Project settings","text":"<p>The first step is to ensure that the Player runs in the background, which is especially useful for testing input with a simulator. To enable this, go to <code>Edit &gt; Project Settings</code>, then navigate to the <code>Player</code> tab, and make sure the <code>Run In Background</code> option is checked.</p> <p></p>"},{"location":"developers/unity-setting-up-project/#add-initi-playground-sdk-to-the-scene","title":"Add Initi Playground SDK to the scene","text":"<ul> <li>Find the INITI Playground SDK prefab in <code>Packages &gt; Initi Playground &gt; Runtime &gt; Prefabs</code>, then drag and drop it into the scene.</li> </ul> <ul> <li>In the <code>Hierarchy</code> window, select the <code>input</code> GameObject within the main <code>InitiPlaygroundSDK</code> GameObject. Customize the properties of the <code>Initi Input Controller</code> according to your preferences.</li> </ul> Input Managers This is a list of Initi Input objects that are registered as input data providers. By default, the project is configured with TUIO input, which handles touch data from the sensor, and mouse input for testing purposes. If you prefer the game not to be controlled by the mouse, you can remove the <code>Initi Mouse Input</code> from this list. Duplicate Hit Radius A hit is considered a duplicate and is ignored if multiple hits occur within the same radius and time frame. The radius is defined in world units. Duplicate Hit Time A hit is considered a duplicate and is ignored if multiple hits occur within the same radius and time frame. The time is defined in second. Miss Effect Distance Specifies the distance from the camera where the miss effect will be spawned. This setting is particularly useful when using a perspective camera. Miss Effect Default effect prefab to be spawned on touch if player didnt hit any other object. Miss Sound Default effect sound to be played on touch if player didnt hit any other object. <p>After adding the <code>InitiPlaygroundSDK</code> prefab to your scene, touch functionality is enabled automatically. You can test this in Play mode. Since no interactive objects are present yet, clicking anywhere in the scene triggers a default miss effect prefab. Experiment with the <code>Initi Input Controller</code> properties for duplicate hit and miss effect settings to observe how these adjustments influence input behavior.</p> <p></p>"},{"location":"developers/unity-setting-up-project/#enable-exit-button","title":"Enable exit button","text":"<p>The final step is to enable the Exit Button. Since the Exit Button is rendered on the <code>UI</code> layer using a <code>Screen Space - Camera</code> canvas, you'll need to assign your Camera to the Canvas.</p> <ul> <li>In the <code>Hierarchy</code> window, select the <code>uiOverlay</code> GameObject within the main <code>InitiPlaygroundSDK</code> GameObject.</li> <li>Assign your Camera to the Canvas using <code>Inspector</code></li> </ul> <p></p> <ul> <li> <p>You can now test the Exit Button in Play mode. It should function correctly when clicked. To prevent accidental exits, you'll need to hold the button for about 2 seconds until it triggers and closes the game. During this time, the Exit Button will display a red fill to indicate the countdown. </p> <p>Note</p> <p>Please note that to fully test the exit functionality, you must build the game, as it cannot be tested within the editor.</p> </li> </ul> <p></p> <p></p> <p>Testing touch using simulator</p> <p></p>"},{"location":"developers/util-scripts/","title":"Pre-made utility scripts","text":"<p>Utility scripts are designed to manage the lifecycle of objects spawned through behavior scripts. While many of these scripts are intuitive, we'll provide a closer look at each one to help you understand their functionality and applications. You can find these utility scripts under <code>Initi &gt; Behaviour &gt; Utils</code>.</p>"},{"location":"developers/util-scripts/#destroy-after-time","title":"Destroy After Time","text":"<p>The <code>Destroy After Time</code> script is used to automatically remove a <code>GameObject</code> after a specified duration. This script is useful for managing the lifespan of temporary objects, such as effects or projectiles, that should not persist indefinitely in your scene.</p> <p></p> Destroy Time Min The minimum time (in seconds) that the <code>GameObject</code> will remain in the scene before it is eligible for destruction. This parameter sets the lower bound for the destruction timer, ensuring that the object is not destroyed before this minimum duration has passed. The object's actual destruction time will be randomly selected between the <code>Destroy Time Min</code> and <code>Destroy Time Max</code> values, providing a controlled range for how long the object remains active. Destroy Time Max The maximum time (in seconds) before the <code>GameObject</code> is automatically destroyed. This sets the upper limit of the object's lifespan, ensuring it will not persist beyond this duration. The object's actual destruction time will be randomly selected between the <code>Destroy Time Min</code> and <code>Destroy Time Max</code> values, providing a controlled range for how long the object remains active. Simulate Hit On Destroy When enabled, it triggers a simulated hit event on the <code>GameObject</code>'s behaviors and those of its child objects just before the <code>GameObject</code> is destroyed. This allows any attached behaviors to react as if the object was interacted with by the user, even though it is about to be removed from the scene."},{"location":"developers/util-scripts/#destroy-after-animation","title":"Destroy After Animation","text":"<p>This utility script retrieves the duration of the current animation from the <code>Animator</code> component and destroys the <code>GameObject</code> once the animation completes. It requires an <code>Animator</code> component to be attached to the same <code>GameObject</code>.</p> <p></p> Simulate Hit On Destroy When enabled, it triggers a simulated hit event on the <code>GameObject</code>'s behaviors and those of its child objects just before the <code>GameObject</code> is destroyed. This allows any attached behaviors to react as if the object was interacted with by the user, even though it is about to be removed from the scene."},{"location":"developers/util-scripts/#destroy-when-invisible","title":"Destroy When Invisible","text":"<p>This script automatically deletes the <code>GameObject</code> when it becomes invisible. It flags the object as visible when <code>OnBecameVisible()</code> is called and destroys it when <code>OnBecameInvisible()</code> is triggered. This is particularly useful for managing objects with physics or gravity that fall out of view.</p>"},{"location":"developers/util-scripts/#destroy-on-particles-finish","title":"Destroy On Particles Finish","text":"<p>This script manages the lifecycle of a <code>GameObject</code> by waiting for all <code>Particle Systems</code> on the object and its children to complete their emission. Once all particles have ceased, the script automatically destroys the <code>GameObject</code>.</p> <p></p> Simulate Hit On Destroy When enabled, it triggers a simulated hit event on the <code>GameObject</code>'s behaviors and those of its child objects just before the <code>GameObject</code> is destroyed. This allows any attached behaviors to react as if the object was interacted with by the user, even though it is about to be removed from the scene."},{"location":"developers/util-scripts/#dont-destroy-on-scene-load","title":"Don't Destroy On Scene Load","text":"<p>This helper component marks the <code>GameObject</code> to persist through scene reloads by calling the <code>DontDestroyOnLoad()</code> method.</p>"},{"location":"developers/util-scripts/#change-light-intensity","title":"Change Light Intensity","text":"<p>This component animates the light intensity over time. Optionally, it can destroy the <code>GameObject</code> once the animation ends. It's useful for effects that require a fading light effect, allowing them to be removed from the scene once the fade is complete.</p> <p></p> Duration Specifies the duration (in seconds) for which the light intensity will be animated. Delay Specifies the delay (in seconds) before the light intensity animation begins. Final Intensity Defines the target intensity value that the light will animate towards over the specified duration. Auto Destroy If enabled, the <code>GameObject</code> will be automatically destroyed once the light intensity animation completes. This is useful for automatically removing objects after they have finished their visual effect."},{"location":"developers/util-scripts/#simple-animation","title":"Simple Animation","text":"<p>A utility script that animates a sequence of sprites at a specified frame rate. With the option to destroy the <code>GameObject</code> once the animation is complete, it\u2019s ideal for simple sprite sheet effects that can be instantiated and left to run without further management.</p> <p></p> Sprites A list of sprites that will be played in sequence to create the animation. Fps The frames per second at which the sprites are played, determining the speed of the animation. Destroy After Finish If enabled, the GameObject will be automatically destroyed after the sprite animation completes. Simulate Hit On Destroy When enabled, it triggers a simulated hit event on the <code>GameObject</code>'s behaviors and those of its child objects just before the <code>GameObject</code> is destroyed. This allows any attached behaviors to react as if the object was interacted with by the user, even though it is about to be removed from the scene. <p>Combined with the pre-made behaviors, these utility scripts will help you quickly set up a simple, game-ready environment in INITI Playground. In the next section, we\u2019ll explore how you can extend this functionality by implementing interactive objects with custom logic.</p> <p></p> <p>Extending functionality</p> <p></p>"},{"location":"help/","title":"Getting Help","text":"<p>Please start by browsing through our Frequently Asked Questions. We've compiled a comprehensive list of common queries and their answers to help you quickly find the information you need.</p> <p>If you don't find what you're looking for in the FAQ section, don't worry. You can reach out directly to our team using the contact form. Simply fill it out with your question or concern, and we will get back to you as soon as possible.</p> <p></p> <p></p> <p>Frequently Asked Questions</p> <p></p>"},{"location":"help/contact/","title":"Contact us","text":"First Name                 Last Name                 Email                 Note                 Submit                 Thank you for reaching out to us!           We will get back to you as soon as possible.                   Submitting the form...                   Something went wrong!           Please try again later."},{"location":"help/faq/","title":"FAQ","text":""},{"location":"help/faq/#general-questions","title":"General Questions","text":"What is INITI Playground and how does it work? <p>INITI Playground is an interactive platform designed to integrate virtual games into the real world. The platform encourages playful interactions, natural movement, and brings people together to socialize using game-like stories. The technology can transform any flat surface into a multi-touch area, turning it into a gaming stage of unlimited size, while simultaneously engaging an unlimited number of players in front of our interactive walls.</p> Where can I get INITI Playground? <p>You can order the INITI Playground directly from our official website. Simply visit our order page to explore options and place your order.</p> For whom is INITI Playground best suited? <p>INITI Playground is ideal for environments that emphasize interactive, educational, and social experiences. Our primary customers include science centers, kindergartens, museums, galleries, amusement parks, and kid centers. It\u2019s also perfect for public spaces and events such as festivals and celebrations, or anywhere with large groups of people looking for engaging, interactive fun.</p> Can I install INITI Playground myself? <p>Yes, absolutely! We've optimized the INITI Playground over the years to ensure that installation and operation are as simple and user-friendly as possible.</p> Is it possible to add more content to INITI Playground? <p>Yes, you can create custom games using our SDK. For detailed instructions on how to develop your own games, please refer to the Developers section of this documentation. Additionally, our team is available to assist in developing tailored experiences for your needs. For more information, please don't hesitate to contact us.</p> Where can I find support if I have more questions about INITI Playground? <p>If you need help, you can contact the INITI support team via the contact form in the Help section of this documentation.</p>"},{"location":"help/faq/#delivery-and-shipping","title":"Delivery and Shipping","text":"What is the delivery method and time? <p>We deliver our products worldwide. Typically, we dispatch your order within 5 working days. However, during periods of higher demand, this timeframe may be extended. All shipments are insured, and the delivery time will vary depending on the distance to the destination.</p> Can I return INITI Playground? <p>Yes, you can return INITI Playground within 14 days without providing a reason. However, the entire system must be complete, undamaged, and free from any signs of use.</p> Do you also supply soft balls? <p>Yes, soft balls are available for purchase on our website in quantities of 50 and 100. If you would like to order a larger quantity, please don't hesitate to contact us.</p> Do you offer discounts? <p>Yes, we offer discounts for purchases of 3 or more INITI Playground systems. For details on the discount amount, please contact us with your request.</p>"},{"location":"help/faq/#technical-questions","title":"Technical Questions","text":"Is INITI Playground compatible with LED walls? <p>Yes, the INITI Playground system is fully compatible with LED walls. In fact, LED walls are an ideal solution for our system, as they are less sensitive to varying light conditions.</p> Are the projector and sound system included? <p>No, the INITI Playground system does not include the projector and sound system. However, we offer personalized advice to help you find the best possible solutions for your premises.</p> How long does the installation take? <p>The most time-consuming part of the installation is mounting the sensor and projector. Once that's complete, the rest of the installation and calibration can typically be finished in about half an hour.</p> What instruments can be used to play the games? <p>Most of our games are designed to be played with soft balls. Additionally, we offer games that can be played using a fishing rod or paint roller. All games can also be played with your hands.</p>"},{"location":"installation/","title":"Hardware Installation Guide","text":"<p>Welcome to the Hardware Installation Guide for INITI Playground. In this section of the documentation, we\u2019ll cover everything you need to get your system up and running. You\u2019ll find detailed information on what\u2019s included in the INITI Playground package, how to select the ideal wall and projector for the best experience, and step-by-step instructions on how to install the sensor and connect the computer. Let\u2019s get started with setting up your playground!</p> <p></p> <p></p> <p>Unboxing the INITI Playground</p> <p></p>"},{"location":"installation/choosing-projector/","title":"Choosing the right projector","text":"<p>Since every space has unique dimensions and lighting conditions, the projector is not included with the INITI Playground package. You will need to select a projector based on your specific requirements. Here are the three main factors to consider:</p> <ul> <li>Projection Distance: To minimize shadows cast by players, a short-throw projector is recommended. These projectors allow you to place the device closer to the wall, reducing interference from players standing in front of the projection area.</li> <li>Projector Brightness: Ensure the projector is bright enough for the lighting conditions of your space. A higher brightness (measured in lumens) will be necessary in environments with strong ambient light to maintain clear visibility of the projection.</li> <li>Resolution: A minimum resolution of Full HD (1080p) is recommended for INITI Playground, but the system also supports higher resolutions, including 4K, for enhanced visual clarity and detail.</li> </ul> <p>Recommended Projectors</p> <p>We've put together an updated list of projectors that work great with the INITI Playground gaming console. Click here to view the document.</p> <p>For a visual guide on selecting the right projector, please check the video below. If you have any questions or need further assistance, feel free to contact us \u2014 we're happy to help!</p> <p></p> <p></p> <p>Sensor installation</p> <p></p>"},{"location":"installation/choosing-wall/","title":"Choosing the right wall","text":"<p>When selecting a wall for your INITI Playground setup, there are a few important considerations:</p> <ul> <li>Solid Structure: The wall should be sturdy and durable enough to withstand interactions such as players throwing soft balls or touching it with their hands. A solid surface ensures consistent touch accuracy and player safety.</li> <li>Flat Surface: The wall must be as flat as possible to avoid disruptions in the interactive experience. Uneven surfaces can interfere with projection quality and touch recognition.</li> <li>Minor Obstacles: Small obstacles, such as electrical outlets or light switches, are acceptable as long as they don't protrude more than 5 cm from the surface. These should not affect the touch recognition.</li> </ul> <p>Choosing the right wall is key to ensuring a smooth and enjoyable interactive experience for players. For a detailed explanation, be sure to check the video below on selecting the right wall for INITI Playground.</p> <p></p> <p></p> <p>Choosing the right projector</p> <p></p>"},{"location":"installation/computer-installation/","title":"Wiring guide","text":"<p>In this section, you'll find a video that demonstrates how to properly connect the sensor, projector, sound system, and other necessary components to your computer, ensuring that everything is set up to start the INITI Playground. Check the video below for a step-by-step visual guide. If you encounter any issues, feel free to contact us for support.</p> <p> </p>"},{"location":"installation/sensor-installation/","title":"Sensor installation","text":"<p>There are two ways to install the INITI Playground sensor: mounting it to the ceiling or to the wall. Depending on your space, you can choose the method that works best for you:</p> <ol> <li> <p>Mounting the sensor on the ceiling</p> <ul> <li>Remove the front part of the sensor holder.</li> <li>Attach the remaining part of the holder to the ceiling using screws and dowels.</li> </ul> </li> <li> <p>Mounting the sensor to the wall</p> <ul> <li>First, screw the front part of the holder directly to the wall.</li> <li>Secure the rest of the holder to the front part using two nuts and tighten them firmly.</li> </ul> </li> </ol> <p> </p> <p> </p> <p>In both cases, ensure that the top of the sensor is approximately 3 cm from the projection wall. The sensor uses an invisible laser beam that should rotate as parallel as possible to the wall for optimal performance.</p> <p>Note</p> <p>If the sensor becomes misaligned during installation, use an Allen key #5 to adjust the front screws of the holder. Rotate the screws until the sensor is horizontal and aligned with the wall. You can check the sensor's balance in the <code>Sensor Calibration</code> section under <code>Settings</code>.</p> <p>For a visual guide, please refer to the video below.</p> <p></p> <p>Final tip</p> <p>To ensure the sensor detection surface is level and covers the entire projection wall, align the sensor by first using the screws to get the blue sensor line to a horizontal position. Then, use only the bottom screw to shift the blue line down, positioning the sensor's detection surface 5-10 cm above the entire projection area.</p> <p>Wiring guide</p> <p></p>"},{"location":"installation/space-requirements/","title":"Space requirements","text":"<p>In this section, we\u2019ve included a video that outlines the essential and recommended space requirements for setting up your INITI Playground. The video covers:</p> <ul> <li>Projection Area: The minimum and maximum dimensions needed for the interactive wall, as well as the ideal space for optimal gameplay.</li> <li>Soft Ball Size: Specifications on the minimum size of soft balls that can be used with the system to ensure accuracy and fun interaction.</li> <li>Projector Placement: How much room is needed for the projector to function effectively without obstructing the gameplay area.</li> <li>Player Space: Recommendations on how much distance players should maintain from the wall for an immersive and comfortable experience.</li> </ul> <p>Make sure to check the video and measure your available space to ensure a smooth installation and gameplay experience. Proper spacing is crucial to allow for safe movement.</p> <p></p> <p></p> <p>Choosing a wall</p> <p></p>"},{"location":"installation/whats-in-the-box/","title":"Unboxing the INITI Playground","text":"<p>To get started with your INITI Playground, we\u2019ve created a video that walks you through the unboxing process and showcases everything included in the box. Watching this video will give you a clear understanding of all the components that come with your system, ensuring you have everything you need before beginning installation.</p> <p></p> <p> In addition to the video, here\u2019s a list of items included in the INITI Playground package:</p> Item Quantity Media server 1x Power adapter for media server 1x Touch sensor 1x PoE injector 1x LAN cables 2x External audio card 1x Bluetooth keyboard 1x Printed wiring plan 1x <p>Make sure to verify that all components are present before moving on to the installation process. If anything is missing or damaged, please contact us right away for assistance.</p> <p>Space requirements</p> <p></p>"},{"location":"setup/","title":"Initial Setup, Calibration, and User Guide","text":"<p>Welcome to the setup and user guide for INITI Playground.  This section will walk you through the initial setup process, ensuring everything is correctly calibrated and connected. Learn how to connect your system to the internet, install updates, and configure settings for optimal user experience. With our step-by-step instructions, you'll have your INITI Playground up and running in no time, ready to provide an engaging and immersive environment.</p> <p></p> <p>Getting started</p> <p></p>"},{"location":"setup/advanced-sensor-calibration/","title":"Advanced sensor calibration","text":"<p>Advanced sensor calibration allows you to fine-tune the calibration using a grid-based warping input. This process is optional but highly beneficial when the wall is not perfectly flat or when certain areas of the projection require higher precision in touch positioning and visual response alignment.</p>"},{"location":"setup/advanced-sensor-calibration/#starting-advanced-calibration","title":"Starting advanced calibration","text":"<ul> <li>Open the UI and navigate to the <code>Settings</code> tab located at the top of the screen.</li> <li>Find and click on the <code>Advanced Calibration</code> section.</li> <li>Click <code>START CALIBRATION</code> button</li> </ul>"},{"location":"setup/advanced-sensor-calibration/#controls","title":"Controls","text":"<p>To fine-tune the calibration, use the mouse and keyboard to adjust the grid. Below is a table of controls:</p> Shortcut Action Mouse Left-click select single point Shift + Mouse Left-click select multiple points V select vertical line H select horizontal line Arrows move selected points R reset selected points Esc save and exit"},{"location":"setup/advanced-sensor-calibration/#moving-the-grid","title":"Moving the grid","text":"<p>To adjust the grid, select the points you want to move and reposition them using the arrow keys. You can select individual points, multiple points, or entire horizontal and vertical lines. Additionally, you can reset specific points to their default (unwarped) positions by selecting them and pressing the <code>R</code> key. Below are some examples:</p> Selecting pointsVertical lineHorizontal line <p></p> <p></p> <p></p>"},{"location":"setup/advanced-sensor-calibration/#testing-calibration","title":"Testing calibration","text":"<p>During the grid setup, it's important to test the calibration by touching the wall. When you touch the wall, a blue cross should appear at the point of contact, ensuring accurate alignment between touch position and visual response. It is recommended to perform this test with an assistant: one person adjusts the grid while the other touches the wall to see where the hit is registered. Refer to the image below for an illustration of this process.</p> <p></p>"},{"location":"setup/advanced-sensor-calibration/#resetting-advanced-calibration","title":"Resetting advanced calibration","text":"<p>To discard the current advanced calibration, click the <code>Reset Calibration</code> button at the bottom of the screen.</p> <p></p> <p>To prevent accidental resets, you will need to confirm this action by clicking <code>OK</code></p> <p></p>"},{"location":"setup/advanced-sensor-calibration/#video-guide","title":"Video guide","text":"<p>For additional guidance, check out our video tutorial below.</p> <p></p> <p>Now that the sensor is successfully calibrated, it's time to move on to the next step: connecting your INITI Playground to the internet. This will enable you to access updates or download new games. Proceed to the next section for detailed instructions on how to connect your system to the internet.</p> <p>Connecting to the internet</p> <p></p>"},{"location":"setup/aspect-ratio/","title":"Choosing aspect ratio","text":"<p>Before starting the sensor calibration process, it is essential to select the correct aspect ratio for your projection. Calibration is highly dependent on the projection size, so the INITI Playground must be recalibrated each time the aspect ratio is changed.</p>"},{"location":"setup/aspect-ratio/#supported-aspect-ratios","title":"Supported aspect ratios","text":"<p>INITI Playground supports four aspect ratios</p> Aspect Ratio 16:9 16:10 4:3 5:4 Recommended yes - - -"},{"location":"setup/aspect-ratio/#selecting-aspect-ratio","title":"Selecting aspect ratio","text":"<ol> <li> <p>Navigate to the Settings Tab:</p> <ul> <li>Open the UI and click on the <code>Settings</code> tab located at the top of the screen</li> </ul> </li> <li> <p>Choose Aspect Ratio:</p> <ul> <li>In the Settings menu, locate the section for aspect ratio settings.</li> <li> <p>Select the desired aspect ratio (5:4, 4:3, 16:9, or 16:10) from the available options.</p> <p> </p> </li> </ul> </li> <li> <p>Confirm selection:</p> <ul> <li> <p>After changing the aspect ratio, the sensor calibration must be redone. Click <code>OK</code> to proceed.</p> <p> </p> </li> </ul> </li> </ol> <p>Once you have chosen and confirmed the correct aspect ratio, you can proceed with the calibration process, confident that your projection size has been accurately accounted for.</p> <p>Sensor calibration</p> <p></p>"},{"location":"setup/connecting-to-the-internet/","title":"Connecting to the internet","text":"<p>INITI Playground supports automatic updates. To receive notifications when a new update is available, you will need to be connected to the internet via Wi-Fi.</p>"},{"location":"setup/connecting-to-the-internet/#locating-wi-fi-settings","title":"Locating Wi-Fi settings","text":"<ul> <li>Open the UI and navigate to the <code>Settings</code> tab at the top of the screen.</li> <li>In the <code>General</code> settings menu, find the Wi-Fi section, as shown in the picture below.</li> </ul>"},{"location":"setup/connecting-to-the-internet/#connecting-to-wi-fi-network","title":"Connecting to Wi-Fi network","text":"<ul> <li>In the sound section, find the <code>NETWORK/WIFI</code> dropdown list.</li> <li>Select your Wi-Fi network from the list.</li> </ul> <ul> <li>Enter the password to your Wi-Fi.</li> </ul> <ul> <li>Press <code>CONNECT</code> button. If the Wi-Fi connection is successful, you will receive a notification stating \"Successfully connected to network XXX.\" If there is an issue, such as an incorrect password, you will see an error message indicating \"Unable to join the network.\"</li> </ul> Successfully connectedConnection error"},{"location":"setup/connecting-to-the-internet/#disconnecting-from-wi-fi-network","title":"Disconnecting from Wi-Fi network","text":"<p>To disconnect from the Wi-Fi network, for instance, if you need to connect to a different network, click the <code>DISCONNECT</code> button. You will then see a notification confirming that you have been successfully disconnected.</p> <p></p> <p>Getting updates</p> <p></p>"},{"location":"setup/enabling-touch/","title":"Enabling touch in games tab","text":"<p>Enabling touch creates a more interactive experience, allowing users to select and launch games by simply touching the wall. By default, this feature is turned off because the sensor needs to be calibrated first. You can turn it on or off in the Games tab.</p>"},{"location":"setup/enabling-touch/#enable-touch","title":"Enable touch","text":"<ul> <li>Open the UI and navigate to the <code>Games</code> tab at the top of the screen.</li> <li>In the <code>Games</code> tab, click the touch icon in the top right corner, as illustrated in the picture below.</li> </ul> <ul> <li>Click <code>OK</code> to confirm</li> </ul> <ul> <li>Once confirmed, the touch icon will turn blue, indicating that touch is enabled. You can now select and launch games by touching the wall.</li> </ul>"},{"location":"setup/enabling-touch/#disable-touch","title":"Disable touch","text":"<p>Sometimes it is preferable to disable touch functionality to prevent users from switching games, thereby giving control over INITI Playground to the supervisor. In such cases, it is advisable to turn off touch and allow the supervisor to select games using a wireless keyboard.</p> <ul> <li>Open the UI and navigate to the <code>Games</code> tab at the top of the screen.</li> <li>In the <code>Games</code> tab, click the touch icon in the top right corner, as illustrated in the picture below.</li> </ul> <p></p> <ul> <li>Click <code>OK</code> to confirm</li> </ul> <p></p> <ul> <li>Once confirmed, the touch icon will turn grey, indicating that touch is disabled. Now the games can be selected and launched only using wireless keyboard.</li> </ul> <p>Starting games</p> <p></p>"},{"location":"setup/exit-button/","title":"Exit button configuration","text":"<p>The exit button is included in all games that come with the INITI Playground. It allows users to exit a game and return to the main menu, providing a control over the interactive experience. It can be toggled on or off based on whether games should be started and switched by the players or by the operator.</p>"},{"location":"setup/exit-button/#locating-exit-button-settings","title":"Locating exit button settings","text":"<ul> <li>Open the UI and navigate to the <code>Settings</code> tab at the top of the screen.</li> <li>In the <code>General</code> settings menu, find the section dedicated to Exit Button Configuration, as shown in the picture below.</li> </ul>"},{"location":"setup/exit-button/#exit-button-position","title":"Exit button position","text":"<p>You can configure the exit button to be positioned on the <code>LEFT</code>, on the <code>RIGHT</code>, or <code>DISABLED</code> entirely based on your preferences. Enabling the exit button allows players to control when to end a game session and return to the main menu.</p> <p></p>"},{"location":"setup/exit-button/#exit-button-location","title":"Exit button location","text":"<p>By adjusting the exit button location slider, you can control its vertical position on the screen. This is useful, for instance, if you want to keep the button accessible but out of reach of smaller children.</p> <p>To get visual feedback on the exit button's location in settings, see the \"Exit Button in the Game\" placeholder. When you start a game, the exit button will appear in the same spot as shown in the settings. This is illustrated in the following screenshots.</p> In settingsIn game #1In game #2 <p></p> <p></p> <p></p> <p>Automatically start games</p> <p></p>"},{"location":"setup/exiting-games/","title":"Exiting games","text":"<p>To switch to a different game or return to the main menu, you must first exit the current game. There are two methods available for exiting: using the keyboard or, if touch input is enabled, by directly interacting with the screen.</p>"},{"location":"setup/exiting-games/#using-the-wireless-keyboard","title":"Using the wireless keyboard","text":"<ul> <li>One way to exit a game is by pressing the <code>ESC</code> key on your wireless keyboard. This will close the game and return the INITI Playground to the main menu.</li> </ul>"},{"location":"setup/exiting-games/#using-touch","title":"Using touch","text":"<p>To exit a game using touch, you must first enable this feature in the settings menu (refer to the Exit Button section). Once enabled, players can easily control the games and switch between them by touching the designated exit button on the screen and holding it for 2 seconds. This is particularly useful if you want to give players direct control over game selection and switching.</p> <p></p> <p></p>"},{"location":"setup/factory-reset/","title":"Factory Reset","text":"<p>If you encounter issues with INITI Playground that cannot be resolved through standard troubleshooting, you have the option to perform a factory reset. This process will restore the system to its original settings, effectively clearing all custom configurations and data. Use this feature cautiously, as it will erase any unsaved progress and personalized settings.</p>"},{"location":"setup/factory-reset/#how-to-perform-a-factory-reset","title":"How to Perform a Factory Reset","text":"<ul> <li>Ensure you have access to the keyboard connected to the INITI Playground system.</li> <li>Press and hold the <code>R</code> key on the keyboard.</li> <li>Continue holding the key for approximately 10 seconds.</li> <li>After holding the <code>R</code> key for the required duration, the INITI Playground will automatically begin the reset process, as shown in the following image.</li> </ul> <ul> <li>The system will erase all user data and settings, reverting to the original factory configuration.</li> <li>After rebooting, the INITI Playground will be ready for fresh setup and use.</li> </ul>"},{"location":"setup/game-autostart/","title":"Automatically start games on system power-up","text":"<p>The INITI Playground can be set to automatically launch a designated game upon power-up. This feature makes it perfect for environments such as museums or amusement parks, where seamless, user-independent operation is essential.</p>"},{"location":"setup/game-autostart/#locating-auto-game-launch","title":"Locating auto game launch","text":"<ul> <li>Open the UI and navigate to the <code>Settings</code> tab at the top of the screen.</li> <li>In the <code>General</code> settings menu, find the <code>AUTO GAME LAUNCH</code> drop down list, as shown in the picture below.</li> <li>Select the game you want to automatically start after the system powers on from the dropdown list. To disable the automatic game start, choose <code>OFF</code> from the list.</li> </ul> <p>With this configuration, the INITI Playground can operate independently, providing an uninterrupted and engaging experience for visitors in public spaces.</p> <p>Sound settings</p> <p></p>"},{"location":"setup/get-started/","title":"Getting started","text":"<p>Prerequisites</p> <p>Before diving in, please ensure you have completed the installation process outlined in the Installation part of this documentation. Once the installation is done, this guide will help you get started by providing an overview of the user interface (UI).</p> UI Overview <p>The UI is divided into two main sections: Games and Settings. These can be easily navigated using the tabs located at the top of the screen, as illustrated in the picture below.</p> Games tabSettings tab <p></p> <p>Games tab is your gateway to the interactive experiences available on your INITI Playground. Using this tab, you can browse and launch games either with a mouse or by directly touching the wall.</p> <p></p> <p>In the Settings tab you can customize your system preferences, calibrate touch sensor and manage updates. The Settings tab ensures that INITI Playground is always optimized for the best performance and user experience.</p> <p>Choosing aspect ratio</p> <p></p>"},{"location":"setup/getting-updates/","title":"Download and install updates","text":"<p>Prerequisites</p> <p>Before you can receive updates, your INITI Playground must be connected to the internet. If you haven't completed the previous chapter, please visit the Connecting to the Internet section before proceeding.</p>"},{"location":"setup/getting-updates/#locating-updates-tab","title":"Locating updates tab","text":"<ul> <li>Open the UI and click on the <code>Settings</code> tab located at the top of the screen</li> <li>In the Settings menu, navigate to the <code>About</code> section. Here, you'll find general information about your INITI Playground, including the version, hardware key, and current status, as illustrated in the picture below.</li> </ul> <p><code>Version</code> in top left corner indicates your current version. </p> <p><code>HW key</code> is the unique key for your INITI Playground. It is blurred out in the screenshot for security reasons. </p>"},{"location":"setup/getting-updates/#connection-issues","title":"Connection issues","text":"<p>If there are any connection issues, an error message will appear, as shown in the next screenshot. In this case, please check your Wi-Fi connection or revisit the Connecting to the Internet section.</p> <p></p>"},{"location":"setup/getting-updates/#new-version-available","title":"New version available","text":"<p>If a new version is available, you'll see a notification on the updates icon in the top right corner, as shown in the next screenshot. To download and install the new version, simply click the <code>UPDATE</code> button. The INITI Playground will download and install the update, automatically reset, and launch the new version.</p> <p></p> <p></p> <p>Now that you know how to stay up to date, you can proceed to the next chapter: the Exit button.</p> <p>Exit button</p> <p></p>"},{"location":"setup/restarting-shutting-down/","title":"How to restart or shut down INITI Playground","text":"<ul> <li>To shut down or restart the INITI Playground, simply locate and click the shutdown icon in the top-right corner, as shown in the picture.</li> </ul> <ul> <li>A dialog box will then appear with options to restart, shut down, or cancel. Select the action you wish to perform by clicking the corresponding button.</li> </ul> <p>Enable touch</p> <p></p>"},{"location":"setup/sensor-calibration/","title":"Sensor calibration","text":"<p>Calibrating the sensor is essential to ensure that touch positions accurately correspond with the visual responses in games. These steps will guide you through the calibration process:</p> <ul> <li> <p>Open the UI and click on the <code>Settings</code> tab at the top of the screen. Locate the sensor calibration section, as illustrated in the picture below.</p> <p> </p> <p>Info</p> <p>The red arrow in the top center indicates the ideal location for mounting the sensor. While it is not mandatory to place the sensor in this exact spot, the best results are achieved when the sensor is positioned in the middle of the projection.</p> </li> </ul>"},{"location":"setup/sensor-calibration/#initiating-calibration","title":"Initiating calibration","text":"<p>For sensor calibration, it's best to have an assistant help by touching each of the four red corners of the projection one by one. Your task will be to recognize where the individual marks on the corners of the projection show up on the blue curve of the sensor. Then, using your mouse, drag corresponding corners of the green rectangle to these marks, aligning them with the peaks of the blue curve. These then define our entire touch area.</p> <p>For a detailed demonstration of the sensor calibration process, please check the video below. It will guide you step-by-step through the setup.</p> <p>Warning</p> <p>If you don't see the blue flickering curve or if the marks on the red corners don't appear, it's likely the sensor was installed incorrectly. Please double-check your setup by reviewing the Sensor Installation video.</p>"},{"location":"setup/sensor-calibration/#resetting-calibration","title":"Resetting calibration","text":"<p>To discard the current calibration and start over, click the <code>Reset Calibration</code> button at the bottom of the screen.</p> <p></p> <p>To prevent accidental resets, you will need to confirm this action by clicking <code>OK</code></p> <p></p> <p></p> <p>Now that you're familiar with the basics of calibration, including masking and testing, you're well on your way. For a more precise calibration, explore the Advanced calibration section to refine your setup further.</p> <p>Advanced calibration</p> <p></p>"},{"location":"setup/sound-settings/","title":"Sound settings","text":"<p>The Sound Settings section enables users to configure audio options for the INITI Playground, including adjusting the master volume and selecting the output device.</p>"},{"location":"setup/sound-settings/#locating-sound-settings","title":"Locating sound settings","text":"<ul> <li>Open the UI and navigate to the <code>Settings</code> tab at the top of the screen.</li> <li>In the <code>General</code> settings menu, find the sound section, as shown in the picture below.</li> </ul>"},{"location":"setup/sound-settings/#select-sound-output-device","title":"Select sound output device","text":"<ul> <li>In the sound section, find the <code>SOUND OUTPUT</code> dropdown list.</li> <li>Select your preferred sound output device from the list (e.g., internal speakers, external speakers, projector, headphones).</li> </ul>"},{"location":"setup/sound-settings/#adjust-volume","title":"Adjust volume","text":"<p>Find the <code>VOLUME</code> slider and adjust it to set the overall volume level for the INITI Playground. </p> <p>Note</p> <p>Please note that this controls the general volume. Individual games also have their own settings menus where you can adjust game-specific volume and other related settings.</p> <p>After configuring the volume and selecting the output device, click the <code>TEST SOUND</code> button. This will play a test sound to help you verify that the audio settings are correct and functioning as desired. </p> <p>Restart or Shutdown</p> <p></p>"},{"location":"setup/starting-games/","title":"Selecting and starting games","text":"<p>Once the playground setup and calibration are complete, you likely won't need to visit the settings frequently. The main focus now is on selecting and launching games from the <code>Games</code> tab using either a wireless keyboard or, when touch is enabled, directly by touching the wall.</p>"},{"location":"setup/starting-games/#using-the-wireless-keyboard","title":"Using the wireless keyboard","text":"<ul> <li>Navigate to the <code>Games</code> tab at the top of the screen.</li> <li>Use the touchpad on the wireless keyboard to select the game you want to launch. You can navigate through the games using the arrows on the left and right or by clicking the small icons at the bottom of the screen, as illustrated in the picture below.</li> </ul> <ul> <li>Once you\u2019ve selected the game, click the play button located in the center of the screen to launch it.</li> </ul>"},{"location":"setup/starting-games/#using-touch","title":"Using touch","text":"<ul> <li>Ensure that touch functionality is enabled (refer to the Enabling Touch in the Games Tab section).</li> <li>Select a game by touching the arrows on the sides, using a swipe gesture, or touching the game icons at the bottom of the screen.</li> <li>To launch a game, touch the play button in the center of the screen.</li> <li>For further assistance, you can also watch the video tutorial provided below.</li> </ul> <p>Exiting games</p> <p></p>"},{"location":"setup/video-tutorials/","title":"Video tutorials","text":"<p>The <code>Tutorials</code> section provides users with quick and easy access to instructional videos that help with various settings and features of the INITI Playground. These tutorials are designed to offer step-by-step guidance, making it easier to understand and configure the system to suit your needs.</p>"},{"location":"setup/video-tutorials/#how-to-access-and-use-video-tutorials","title":"How to Access and Use Video Tutorials","text":"<ul> <li>Open the UI and navigate to the <code>Settings</code> tab at the top of the screen.</li> <li>In the <code>Settings</code> menu, find and click on the <code>Tutorials</code> section.</li> </ul> <ul> <li>You will see a list of available video tutorials covering different aspects of the INITI Playground. These may include topics such as configuration, calibration and game selection.</li> <li>Click on a tutorial to watch it.. </li> </ul> <p>Restart or Shutdown</p> <p></p>"}]}